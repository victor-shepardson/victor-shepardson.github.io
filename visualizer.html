<!DOCTYPE html>
<html>
<body>
<h1>
Audio Visualizer with WebGL
</h1>
<table>
	<tr>
		<td><div id='control'></div></td>
		<td><div id='main'></div></td>
	</tr>
</table>
<!-- <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script> -->
<script src="./jquery-1.11.0.js"></script>
<script src="./buffer-loader.js"></script>
<script>
	window.onload = function() {
		var time = 0;
		//init audio stuff
		console.log('init audio...')
		var context;
		try {
			window.AudioContext = window.AudioContext||window.webkitAudioContext;
			context = new AudioContext();
			console.log(context);
		}
		catch(e) {
			alert('Web Audio API is not supported in this browser');
		}
		//load audio
		console.log('loading audio');
		var inputBuffer = null;
		var bufferLoader = new BufferLoader(context, ['./sample.ogg'], function(bufferList){
			inputBuffer = bufferList[0];
			console.log(inputBuffer);
			playSound(inputBuffer);
		});
		bufferLoader.load();
		var fftNode = context.createAnalyser();
		fftNode.fftSize=512;
		fft = new Float32Array(fftNode.frequencyBinCount);
		function playSound(buffer) {
			var source = context.createBufferSource(); // creates a sound source
			source.buffer = buffer;                    // tell the source which sound to play
			source.connect(fftNode);
			source.connect(context.destination);       // connect the source to the context's destination (the speakers)
			source.start(0);                           // play the source now
												 // note: on older systems, may have to use deprecated noteOn(time);
		}
		
		//init gl stuff
		console.log('init graphics...')
		loadShaders();
		var viewportWidth=512, viewportHeight=512;
		var sliderh = 100;
		var numsliders = 5;
		var slider_names = ['frequency','isotropy','orientation','density','gridsize'];
		var slider_text = ["'frequency of noise in pixels'", "'directionality of noise'", "'direction of noise; no effect if isotropy is high'", "'density of impulses/cell for evaluation; trades off performance for accuracy'", "'size of evaluation grid in pixels; controls bandwidth of noise'"];
		var sliders = [];
		var origin=0.;
		for(var i=0; i<numsliders; i++){
			var span = $('<span title='+slider_text[i]+'><\span>').appendTo($('#control'));
			var div = $('<div>').appendTo(span);
			$('<h3>'+slider_names[i]+'<\h3>').appendTo(div);//$('#control'));
			sliders[i] =
				$('<input type="range">')
				.appendTo(div)
				.attr({
					min: 0,
					max: 1,
					step: 0.001,
					value: .5
				});
			$('</span>');
		}
		var gl = $('<canvas/ id = "canvas">')
			.appendTo($('#main'))
			.attr('width', viewportWidth)
			.attr('height', viewportHeight)[0]
			.getContext('experimental-webgl');
			
		gl.clearColor(0.0, 0.0, 0.0, 1.0);
		gl.enable(gl.DEPTH_TEST);

		// create buffer with a rectangle
		var vertexPositionsBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionsBuffer);
		var vertexPositions = [
			1.0, 1.0, 0.0,
			-1.0, 1.0, 0.0,
			1.0, -1.0, 0.0,
			-1.0, -1.0, 0.0
		];

		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositions), gl.STATIC_DRAW);
		vertexPositionsBuffer.itemSize = 3;
		vertexPositionsBuffer.numItems = 4;
		
		var textureCoordinatesBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordinatesBuffer);
		var s = viewportWidth/512.0;
		var t = viewportHeight/512.0;
		var textureCoordinates = [
			s, 1.0,
			0.0, 1.0,
			s, 1-t,
			0.0, 1-t
		];

		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);
		textureCoordinatesBuffer.itemSize = 2;
		textureCoordinatesBuffer.numItems = 4;

		
		//block until all resources loaded
		/*
		blockUntilLoaded();
		function blockUntilLoaded(){
			console.log('blocking until shaders loaded');
			while(!vshader || !fshader) {}
			console.log('loaded');
		}*/
		
		//get rollin'
		var program = createShaderProgram(vertexPositionsBuffer, textureCoordinatesBuffer);
		gl.useProgram(program);

		frame();
		
	/*	
		$(document).keydown( function(event) {
			event.preventDefault();
			var key = event.which;
		});*/

		$(document).mousemove( function(event) {
			event.preventDefault();
			//get pixel position in canvas to pass to shader
			var os = $('#canvas').offset()
			var x = event.pageX-os.left;
			var y = viewportHeight - (event.pageY-os.top);
			//console.log(x); console.log(y);
			gl.uniform2f(program.mouse, x, y);
		});
/*
		$(document).mousedown( function(event) {
			event.preventDefault();
			var key = event.which;
			var x = event.pageX;
			var y = event.pageY;
			if (key==1) {
				gl.uniform1i(program.mouseLeftUniform, 1);
			}
		});

		$(document).mouseup( function(event) {
			event.preventDefault();
			var key = event.which;
			if (key==1) {
				gl.uniform1i(program.mouseLeftUniform, 0);
			}
		});

		$(document).mouseleave( function(event) {
			event.preventDefault();
			gl.uniform2f(program.mouseUniform, 0, 0);
		});
	*/
		var vshader, fshader;
		function loadShaders(){
			console.log("loading shaders...");
			$.ajax({
				url: './vshader.glsl',
				success: function(result) {
					vshader = result;
					console.log('vertex shader');
				},
				async: false
			});
			$.ajax({
				url: './vis.glsl',
				success: function(result) {
					fshader = result;
					console.log('fragment shader');
				},
				async: false
			});
		}
		
		function createShaderProgram(vertexPositionsBuffer, textureCoordinatesBuffer) {
			// create vertex shader
			var vertexShader = gl.createShader(gl.VERTEX_SHADER);
			gl.shaderSource(vertexShader, vshader);
			gl.compileShader(vertexShader);
			if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
				console.log(vshader+"\nvshader: "+gl.getShaderInfoLog(vertexShader));
			}
	  
			// create fragment shader
			var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
			gl.shaderSource(fragmentShader, fshader);
			gl.compileShader(fragmentShader);
			if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
				console.log("fshader: "+gl.getShaderInfoLog(fragmentShader));
			}
			  
			// create and use program
			var program = gl.createProgram();
			gl.attachShader(program, vertexShader);
			gl.attachShader(program, fragmentShader);
			gl.linkProgram(program);
			if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
				console.log("link: "+gl.getProgramInfoLog(program));
			}
			  
			// vertex attribute [position]
			program.vertexPositionAttribute = gl.getAttribLocation(program, "aVertexPosition");
			gl.enableVertexAttribArray(program.vertexPositionAttribute);

			// vertex attribute [texture coordinates]
			program.textureCoordinatesAttribute = gl.getAttribLocation(program, "aTextureCoordinates");
			gl.enableVertexAttribArray(program.textureCoordinatesAttribute);

			program.time = gl.getUniformLocation(program, "time");
			program.b0 = gl.getUniformLocation(program, "b0");
			program.b1 = gl.getUniformLocation(program, "b1");
			program.mouse = gl.getUniformLocation(program, "mouse");
		
			return program;
		}

		
		function mean(array){
			var sum = 0;
			for (var i=0;i<array.length;i++)
				sum+=array[i];
			//console.log(sum/array.length);
			return sum/array.length;
		}
		function sum(array){
			var sum = 0;
			for (var i=0;i<array.length;i++)
				sum+=array[i];
			return sum;
		}

		function frame() {
			var bins = [0,0,0,0,0,0,0,0];
			if(inputBuffer){
			
				fftNode.getFloatFrequencyData(fft);
				//console.log(fft);
				//console.log(sync);
						
				var floor = 100;
				//var m = Math.max(mean(fft),-floor)*(1/floor)+1;
				//if (m>0) console.log(m);
				//sync+=m;
				var n = 1;
				var k = 0;
				for(var i=0;i<bins.length;i++){
					for(var j=0; j<n; j++){
						if(k==fft.length){
							console.log(k);
							break;
						}
						bins[i] += Math.max(fft[k],-floor)*(1/floor)+1;
						k++;
					}
					bins[i]/=n;
					n*=2;
				}
				time+=mean(bins);//bins[0];
				
				if(sum(bins)>0)
					console.log(bins);
			}
			
			gl.uniform4f(program.b0, bins[0], bins[1], bins[2], bins[3]);
			gl.uniform4f(program.b1, bins[4], bins[5], bins[6], bins[7]);
			gl.uniform1f(program.time, time);
			
			gl.viewport(0, 0, viewportWidth, viewportHeight);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		
			// plug buffers to the corresponding vertex attributes
			gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionsBuffer);
			gl.vertexAttribPointer(program.vertexPositionAttribute, vertexPositionsBuffer.itemSize, gl.FLOAT, false, 0, 0);
			gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordinatesBuffer);
			gl.vertexAttribPointer(program.textureCoordinatesAttribute, textureCoordinatesBuffer.itemSize, gl.FLOAT, false, 0, 0);
			gl.drawArrays(gl.TRIANGLE_STRIP, 0, vertexPositionsBuffer.numItems);
			
			window.requestAnimationFrame(frame, gl);
		}
	}
</script>
</body>
</html>