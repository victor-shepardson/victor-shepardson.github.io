var genshader_noise4 = "#extension GL_OES_standard_derivatives : enable\n\n#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\n#endif\n\n#define PI 3.1415926535897932384626\n#define IMPULSE_CAP 100\n#define IMOD 4096\n\nvarying vec2 vTextureCoordinates;\nvarying vec3 position;\n\nuniform float gridSize; //side length of square grid used for evaluation\nuniform float density; //number of impulses / kernel area (accuracy)\nuniform vec2 origin; //offset of image space from texture space\nuniform vec4 sector; //annular sector in frequency domain: fundamental freq, octaves, min orientation, max orientation\n\nuniform vec4 wsector;\nuniform float warp;\n\nstruct gnoise_params{\nmat2 filter, sigma_f_plus_g_inv;\nfloat ainv, a, a_prime_square, density, filterSigma, octaves;\nvec4 sector;\nmat2 jacob;\n};\n\nivec2 bound_grid(ivec2 gpos){\nreturn gpos + IMOD*(1 - gpos/IMOD);\n}\n\n//hash based on Blum, Blum & Shub 1986\n//and Sharpe http://briansharpe.wordpress.com/2011/10/01/gpu-texture-free-noise/\nconst float bbsm = 137023.;//magic product of two primes chosen to have high period without float precision issues\nvec4 bbsmod( vec4 a ) {\nreturn a - floor( a * ( 1.0 / bbsm ) ) * bbsm;\n}\nvec4 bbs(vec4 a) {\nreturn bbsmod(a*a);\n}\nvec4 bbsopt( vec4 a ) {\nreturn fract( a * a * ( 1.0 / bbsm ) ) * bbsm;\n}\nvec4 seed(in ivec2 p){\nvec4 h = vec4(p.xy, p.xy+ivec2(IMOD/2));\nvec4 h0 = bbs(h);\nvec4 h1 = bbsopt(h0.xzxz);\nvec4 h2 = bbsopt(h0.yyww+h1);\n//vec4 h3 = bbsopt(h0.xzxz+h2);\nreturn h2*(1./bbsm);\n}\n\n//permutation polynomial\n//based on Gustavson/McEwan https://github.com/ashima/webgl-noise/\n//and Sharpe http://briansharpe.wordpress.com/2011/10/01/gpu-texture-free-noise/\nconst float pp_epsilon = .01;\nvec4 nextRand(inout vec4 u){//rng\nu = fract(((u*34.0*289.)+1.0)*u+pp_epsilon);\nreturn fract(7.*u);\n}\n\n//approximate poisson distribution uniform u\n//from Galerne, Lagae, Lefebvre, Drettakis\nconst float poisson_epsilon = .001;\nint poisson(inout vec4 u, in float m){\nfloat u1 = nextRand(u).x;\nfloat u2 = nextRand(u).x;\nfloat x = sqrt(-2.*log(u1+poisson_epsilon))*cos(2.*PI*u2);\nreturn int(m+sqrt(m)*x+.5);\n}\n\n//Gabor noise based on Lagae, Lefebvre, Drettakis, Dutre 2011\nvec4 eval_cell(in vec2 cpos, in ivec2 gpos, in ivec2 dnbr, gnoise_params params){\nvec4 u = seed(bound_grid(gpos+dnbr)); //deterministic seed for nbr cell\nint impulses = int(.5+params.density);//poisson(u, params.density); //number of impulses in nbr cell\nvec4 h = params.sector; //annular sector\nfloat a = params.a; //bandwidth\nfloat aps = params.a_prime_square; //intermediate calculations for filtering\nfloat filt_scale = aps*params.ainv*params.ainv;\nvec2 fpos = cpos - vec2(dnbr);//fragment position in cell space\n\nvec4 acc = vec4(0.);\n//for impulses\nfor(int k=0; k<IMPULSE_CAP; k++){\nif(k<impulses){\n//displacement of impulse to fragment\nvec4 delta_x = (fpos.xxxx - nextRand(u))*params.ainv;\nvec4 delta_y = (fpos.yyyy - nextRand(u))*params.ainv;\nvec4 delta_ab = vec4(delta_x.xy, delta_y.xy).xzyw;\nvec4 delta_cd = vec4(delta_x.zw, delta_y.zw).xzyw;\n//impulse frequency, orientation - uniform distribution on input ranges\nvec4 mfreq = pow(vec4(2.), nextRand(u)*params.octaves);\nvec4 ifreq = h.x*mfreq;\nvec4 iorientation = mix(h.zzzz, h.wwww, nextRand(u));\n//evaluate kernel, accumulate fragment value\nvec4 mu_ab = ifreq*vec4(cos(iorientation.xy), sin(iorientation.xy)).xzyw;\nvec4 mu_cd = ifreq*vec4(cos(iorientation.zw), sin(iorientation.zw)).xzyw;\nvec4 phi = nextRand(u); //phase - uniform dist [0, 1]\nvec4 filt_exp = -.5*vec4(\ndot(mu_ab.xy, params.sigma_f_plus_g_inv*mu_ab.xy),\ndot(mu_ab.zw, params.sigma_f_plus_g_inv*mu_ab.zw),\ndot(mu_cd.xy, params.sigma_f_plus_g_inv*mu_cd.xy),\ndot(mu_cd.zw, params.sigma_f_plus_g_inv*mu_cd.zw)\n);\nvec4 delta_ab2 = delta_ab*delta_ab;\nvec4 delta_cd2 = delta_cd*delta_cd;\nvec4 dd = vec4(\ndelta_ab2.xz+delta_ab2.yw,\ndelta_cd2.xz+delta_cd2.yw\n);\nvec4 dm = vec4(\ndot(delta_ab.xy,params.filter*mu_ab.xy),\ndot(delta_ab.zw,params.filter*mu_ab.zw),\ndot(delta_cd.xy,params.filter*mu_cd.xy),\ndot(delta_cd.zw,params.filter*mu_cd.zw)\n);\nacc+= filt_scale/mfreq*exp(-PI*aps*dd+filt_exp)*cos(2.*PI*(dm+phi));\n}else {break;}\n}\nreturn acc;\n}\n\nfloat det2x2(mat2 m){\nreturn (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\nmat2 inv2x2(mat2 m){\nreturn (1./det2x2(m))*mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]);\n}\nmat2 id2x2(){\nreturn mat2(1.,0.,0.,1.);\n}\n\n//annular sector of pink noise\nvec4 gnoise(vec2 pos, gnoise_params params) {\n//compute positions for this fragment\nvec2 temp = pos*params.a;\nvec2 cpos = fract(temp);\nivec2 gpos = bound_grid(ivec2(floor(temp)));\n\nmat2 jacob = params.jacob;\nmat2 jacob_t = mat2(jacob[0][0], jacob[1][0], jacob[0][1], jacob[1][1]);\nmat2 sigma_f_inv = (4.*PI*PI*params.filterSigma*params.filterSigma)*(jacob*jacob_t);\nmat2 sigma_f = inv2x2(sigma_f_inv);\nmat2 sigma_g_inv = (2.*PI*params.ainv*params.ainv)* id2x2();\nmat2 sigma_g = inv2x2(sigma_g_inv);\nmat2 sigma_fg_inv = sigma_f_inv + sigma_g_inv;\nmat2 sigma_fg = inv2x2(sigma_fg_inv);\n\n//filter params\nparams.filter = sigma_fg * sigma_g_inv;\nparams.sigma_f_plus_g_inv = inv2x2(sigma_f + sigma_g);\nparams.a_prime_square = 2.*PI*sqrt(det2x2(sigma_fg));\n\nparams.octaves = params.sector.y;//log2(params.sector.y/params.sector.x);\n\nvec4 value =\neval_cell(cpos, gpos, ivec2(-1, -1), params) +\neval_cell(cpos, gpos, ivec2(-1,  0), params) +\neval_cell(cpos, gpos, ivec2(-1,  1), params) +\neval_cell(cpos, gpos, ivec2( 0, -1), params) +\neval_cell(cpos, gpos, ivec2( 0,  0), params) +\neval_cell(cpos, gpos, ivec2( 0,  1), params) +\neval_cell(cpos, gpos, ivec2( 1, -1), params) +\neval_cell(cpos, gpos, ivec2( 1,  0), params) +\neval_cell(cpos, gpos, ivec2( 1,  1), params);\n\n//float lambda = params.a*params.a*params.density;\n\n//ad hoc attempt to normalize\n//value/=log2(2.+2.*params.density);\nvalue*=(1./PI)*pow(params.density, -.5);\n//value*=(1./3.)/log2(params.density+2.);\nfloat octexp = pow(2., params.octaves);\nvalue*= (1.+params.octaves)*octexp/(2.*octexp-1.);\n\nreturn value;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\nvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\nreturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat rectify( const float f ){\nif( f > 0.0031308 )\nreturn 1.055 * ( pow( f, 1./2.4 ) ) - 0.055;\nelse\nreturn 12.92 * f;\n}\nvec3 xyz2rgb(vec3 c){\nreturn vec3(\nrectify(c.x *  3.2406 + c.y * -1.5372 + c.z * -0.4986),\nrectify(c.x * -0.9689 + c.y *  1.8758 + c.z *  0.0415),\nrectify(c.x *  0.0557 + c.y * -0.2040 + c.z *  1.0570)\n);\n}\n\nvoid main(void){\nvec2 pos = vTextureCoordinates.xy+origin.xy;\ngnoise_params params;\nparams.ainv = gridSize;\nparams.a = 1./params.ainv;\nparams.filterSigma = 1.;\nparams.jacob = mat2(dFdx(vTextureCoordinates.xy),dFdy(vTextureCoordinates.xy));\nparams.sector = sector;\nparams.density = density*(1./PI); //mean impulses per grid cell\n/*\ngnoise_params wparams;\nwparams.ainv = params.ainv;\nwparams.a = params.a;\nwparams.filterSigma = params.filterSigma;\nwparams.jacob = params.jacob;\nwparams.sector = wsector;\nwparams.density = params.density;\n*/\n\nvec4 value = gnoise(pos, params);\nvalue= value*.5+.5;\n\n//monochrome\nvec3 c = value.xyz;//.5*vec3(a_prime_square/(a*a));\n//draw fragment\ngl_FragColor = vec4(c, 1.0);\n}\n";
