var genshader_noise2 = "#extension GL_OES_standard_derivatives : enable\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.1415926535897932384626\n#define IMPULSE_CAP 100\n#define EPSILON .001\n#define C1 4099.\n#define C2 4011.\n\nvarying vec2 vTextureCoordinates;\nvarying vec2 position;\n\nuniform float gridSize; //side length of square grid used for evaluation\nuniform float density; //number of impulses / kernel area (accuracy)\nuniform vec2 origin; //offset of image space from texture space\nuniform float sync; //nonrandomness of phase\nuniform vec4 harmonic; //annular sector in frequency domain: min freq, max freq, min orientation, max orientation\n\nvec2 pos; //fragment position in image space, measured in pixels\nvec2 cpos; //fragment position in cell space: continuous in [0, 1]\nivec2 gpos; //cell position in grid space: integer in [-inf, inf]\nmat2 filter, sigma_f_plus_g_inv;\nfloat a, a_prime_square;\n\nfloat lambda = density/PI; //mean impulses per grid cell\n\nfloat norm = .33/log2(lambda+2.); //attempt to normalize color value\n\nfloat nextRand(inout float u){//rng\nu = fract(C2*cos(u + C1 * cos(u)));\nreturn u;\n}\nfloat seed(in vec2 p){\nvec2 temp = p;\nfloat temp2 = nextRand(temp.x) + temp.y;\nreturn nextRand(temp2);\n}\n\nint poisson(inout float u, in float m){//from Galerne, Lagae, Lefebvre, Drettakis\nfloat u1 = nextRand(u);\nfloat u2 = nextRand(u);\nfloat x = sqrt(-2.*log(u1+EPSILON))*cos(2.*PI*u2);\nreturn int(m+sqrt(m)*x+.5);\n}\n\n//evaluate the contribution to this fragment by a single impulse at displacement delta, in cell with seed u\nfloat eval_impulse(inout float u, in vec2 delta){\n//impulse frequency, orientation - uniform distribution on input ranges\nfloat ifreq = mix(harmonic.x, harmonic.y, nextRand(u));\nfloat iorientation = mix(harmonic.z, harmonic.w, nextRand(u));\n//evaluate kernel, accumulate fragment value\nvec2 omega = vec2(cos(iorientation), sin(iorientation));\nfloat phi = nextRand(u); //phase - uniform dist [0, 1]\nfloat k_prime = a_prime_square/(a*a)*exp(-.5*dot(omega, sigma_f_plus_g_inv*omega));\nreturn k_prime*(exp(dot(delta,delta)*-PI)*cos(2.*PI*(ifreq*gridSize*dot(delta, filter*omega)+phi)));\n//e ^ -(disp^2 / 2*sigma^2)\n}\n\n//evaluate the contribution to this fragment by impulses in the cell at displacement dnbr from this fragment's cell\nfloat eval_cell(in ivec2 dnbr){\nfloat u = seed(vec2(gpos+dnbr)); //deterministic seed for nbr cell\nint impulses = poisson(u, lambda); //number of impulses in nbr cell\nfloat acc = 0.;\n//for impulses\nfor(int k=0; k<IMPULSE_CAP; k++){\nif(k>=impulses){\nbreak;\n}else{ //mysterious bug on windows requires this else\n//position of impulse in cell space - uniform distribution\nvec2 ipos = vec2(nextRand(u), nextRand(u));\n//displacement to fragment\nvec2 delta = (cpos - ipos - vec2(dnbr));//*gridSize;\nacc += eval_impulse(u, delta);\n}\n}\nreturn acc;\n}\n\nfloat det2x2(mat2 m){\nreturn (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\nmat2 inv2x2(mat2 m){\nreturn (1./det2x2(m))*mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]);\n}\n\nmat2 id2x2(){\nreturn mat2(1.,0.,0.,1.);\n}\n\nvoid main(void){\n//compute positions for this fragment\npos = vTextureCoordinates.xy+origin.xy;\nvec2 temp = pos/gridSize;\ncpos = fract(temp);\ngpos = ivec2(floor(temp));\n\na = 1./gridSize;\nfloat sigma = a;\n\nmat2 jacob = mat2(dFdx(vTextureCoordinates.xy),dFdy(vTextureCoordinates.xy));\nmat2 jacob_t = mat2(jacob[0][0], jacob[1][0], jacob[0][1], jacob[1][1]);\nmat2 sigma_f_inv = (4.*PI*PI*sigma*sigma)*(jacob*jacob_t);\nmat2 sigma_f = inv2x2(sigma_f_inv);\nmat2 sigma_g_inv = (2.*PI/(a*a))* id2x2();\nmat2 sigma_g = inv2x2(sigma_g_inv);\nmat2 sigma_fg_inv = sigma_f_inv + sigma_g_inv;\nmat2 sigma_fg = inv2x2(sigma_fg_inv);\n\nfilter = sigma_fg * sigma_g_inv;\nsigma_f_plus_g_inv = inv2x2(sigma_f + sigma_g);\n\na_prime_square = 2.*PI*sqrt(det2x2(sigma_fg));\n\n\nfloat value =\neval_cell(ivec2(-1, -1)) +\neval_cell(ivec2(-1,  0)) +\neval_cell(ivec2(-1,  1)) +\neval_cell(ivec2( 0, -1)) +\neval_cell(ivec2( 0,  0)) +\neval_cell(ivec2( 0,  1)) +\neval_cell(ivec2( 1, -1)) +\neval_cell(ivec2( 1,  0)) +\neval_cell(ivec2( 1,  1));\n\n//normalize / clamp\nvalue*=norm;\nvalue= value*.5+.5;\n\n//monochrome\nvec3 c = vec3(value,value,value);//.5*vec3(a_prime_square/(a*a));\n//draw fragment\ngl_FragColor = vec4(c, 1.0);\n}\n";
