var genshader_noise2 = "#extension GL_OES_standard_derivatives : enable\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.1415926535897932384626\n#define IMPULSE_CAP 100\n#define EPSILON .001\n#define C1 4099.\n#define C2 4011.\n#define C3 137023.\n#define C4 17947.\n#define ITOF (4.6566129e-10)\n#define IMOD 4096\n\nvarying vec2 vTextureCoordinates;\nvarying vec3 position;\n\nuniform float gridSize; //side length of square grid used for evaluation\nuniform float density; //number of impulses / kernel area (accuracy)\nuniform vec2 origin; //offset of image space from texture space\nuniform float sync; //nonrandomness of phase\nuniform vec4 harmonic; //annular sector in frequency domain: min freq, max freq, min orientation, max orientation\n\nmat2 filter, sigma_f_plus_g_inv;\nfloat a, a_prime_square;\n\nfloat lambda = density*(1./PI); //mean impulses per grid cell\n\nivec2 bound_grid(ivec2 gpos){\nreturn gpos + IMOD*(1 - gpos/IMOD);\n}\n\nconst float bbsm = C3;//61.;\nvec4 bbsmod( vec4 a ) {\nreturn a - floor( a * ( 1.0 / bbsm ) ) * bbsm;\n}\nvec4 bbs(vec4 a) {\nreturn bbsmod(a*a);\n}\nvec4 bbsopt( vec4 a ) {\nreturn fract( a * a * ( 1.0 / bbsm ) ) * bbsm;\n}\n/*\nfloat seed (in vec2 p){\nreturn fract(sin(dot(p.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}*/\n/*float nextRand(inout float u){\nvec2 temp = vec2(u, u+1.);\ntemp.y = seed(temp);\nreturn u = seed(temp);\n}\n*/\nfloat nextRand(inout float u){//rng\n//u = fract(C2*cos(u + C1 * cos(u)));\n//u = cos(u*C1*cos(u*C2+C3)+C4);\nu = fract(((u*34.0*289.)+1.0)*u+.01);\nreturn fract(7.*u);\n//u = fract(sin(u)*43758.5453);\n//return u;\n}\n\nfloat seed(in ivec2 p){\nvec4 h = vec4(p.xy, p.xy+ivec2(1));\nvec4 h0 = bbs(h);\nvec4 h1 = bbsopt(h0.xzxz);\nvec4 h2 = bbsopt(h0.yyww+h1);\n//vec4 h3 = bbsopt(h0.xzxz+h2);\nreturn h2.x*(1./bbsm);\n}\n\n/*\nfloat nextRand(inout int u){\n//u = u*3039177861;\n//u = u * -1255789435;\n//return float(u)*ITOF*.5+.5;\nu = mod(u*16807, 2147483647);\nreturn float(u)*ITOF;\n}\nint seed(in ivec2 p){\nint u = p.x;\nnextRand(u);\nu+=p.y;\nnextRand(u);\nreturn u;\n}\n*/\nint poisson(inout float u, in float m){//from Galerne, Lagae, Lefebvre, Drettakis\nfloat u1 = nextRand(u);\nfloat u2 = nextRand(u);\nfloat x = sqrt(-2.*log(u1+EPSILON))*cos(2.*PI*u2);\nreturn int(m+sqrt(m)*x+.5);\n}\n\n//evaluate the contribution to this fragment by a single impulse at displacement delta, in cell with seed u\nfloat eval_impulse(inout float u, in vec2 delta){\n//impulse frequency, orientation - uniform distribution on input ranges\nfloat ifreq = mix(harmonic.x, harmonic.y, nextRand(u));\nfloat iorientation = mix(harmonic.z, harmonic.w, nextRand(u));\n//evaluate kernel, accumulate fragment value\nvec2 mu = ifreq*vec2(cos(iorientation), sin(iorientation));\nfloat phi = nextRand(u); //phase - uniform dist [0, 1]\nfloat k_prime = a_prime_square/(a*a)*exp(-.5*dot(mu, sigma_f_plus_g_inv*mu));\nreturn k_prime*exp(-PI*a_prime_square*dot(delta,delta))*cos(2.*PI*(dot(delta, filter*mu)+phi));\n//e ^ -(disp^2 / 2*sigma^2)\n}\n\n//evaluate the contribution to this fragment by impulses in the cell at displacement dnbr from this fragment's cell\nfloat eval_cell(in vec2 cpos, in ivec2 gpos, in ivec2 dnbr){\nfloat u = seed(bound_grid(gpos+dnbr)); //deterministic seed for nbr cell\n//int u = seed(gpos+dnbr);\nint impulses = poisson(u, lambda); //number of impulses in nbr cell\nfloat acc = 0.;\n//for impulses\nfor(int k=0; k<IMPULSE_CAP; k++){\nif(k>=impulses){\nbreak;\n}else{ //mysterious bug on windows requires this else\n//position of impulse in cell space - uniform distribution\nvec2 ipos = vec2(nextRand(u), nextRand(u));\n//displacement to fragment\nvec2 delta = (cpos - ipos - vec2(dnbr))*gridSize;\nacc += eval_impulse(u, delta);\n}\n}\nreturn acc;\n}\n\nfloat det2x2(mat2 m){\nreturn (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\nmat2 inv2x2(mat2 m){\nreturn (1./det2x2(m))*mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]);\n}\nmat2 id2x2(){\nreturn mat2(1.,0.,0.,1.);\n}\n\nvoid main(void){\n//compute positions for this fragment\nvec2 pos = vTextureCoordinates.xy+origin.xy;\nvec2 temp = pos/gridSize;\nvec2 cpos = fract(temp);\nivec2 gpos = bound_grid(ivec2(floor(temp)));\n\nfloat norm = .33/log2(lambda+2.); //attempt to normalize color value\n\na = 1./gridSize;\nfloat filterSigma = 1.;\n\nmat2 jacob = mat2(dFdx(vTextureCoordinates.xy),dFdy(vTextureCoordinates.xy));\nmat2 jacob_t = mat2(jacob[0][0], jacob[1][0], jacob[0][1], jacob[1][1]);\nmat2 sigma_f_inv = (4.*PI*PI*filterSigma*filterSigma)*(jacob*jacob_t);\nmat2 sigma_f = inv2x2(sigma_f_inv);\nmat2 sigma_g_inv = (2.*PI/(a*a))* id2x2();\nmat2 sigma_g = inv2x2(sigma_g_inv);\nmat2 sigma_fg_inv = sigma_f_inv + sigma_g_inv;\nmat2 sigma_fg = inv2x2(sigma_fg_inv);\n\nfilter = sigma_fg * sigma_g_inv;\nsigma_f_plus_g_inv = inv2x2(sigma_f + sigma_g);\n\na_prime_square = 2.*PI*sqrt(det2x2(sigma_fg));\n/*\nfloat u = seed(gpos);\nfloat value = u;\nvalue = nextRand(u);\n*/\nfloat value =\neval_cell(cpos, gpos, ivec2(-1, -1)) +\neval_cell(cpos, gpos, ivec2(-1,  0)) +\neval_cell(cpos, gpos, ivec2(-1,  1)) +\neval_cell(cpos, gpos, ivec2( 0, -1)) +\neval_cell(cpos, gpos, ivec2( 0,  0)) +\neval_cell(cpos, gpos, ivec2( 0,  1)) +\neval_cell(cpos, gpos, ivec2( 1, -1)) +\neval_cell(cpos, gpos, ivec2( 1,  0)) +\neval_cell(cpos, gpos, ivec2( 1,  1));\n\n//normalize / clamp\nvalue*=norm;\nvalue= value*.5+.5;\n\n//monochrome\nvec3 c = vec3(value,value,value);//.5*vec3(a_prime_square/(a*a));\n//draw fragment\ngl_FragColor = vec4(c, 1.0);\n}\n";
