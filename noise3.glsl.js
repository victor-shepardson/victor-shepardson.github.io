var genshader_noise3 = "#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\n#endif\n\n#define PI 3.1415926535897932384626\n#define IMPULSE_CAP 128\n#define IMOD 4096\n\nstruct gnoise_params{ //struct for input params to gabor noise\nfloat a, density, filterSigma, octaves;\nvec4 sector;\nmat2 jacob;\n};\n\nstruct gnoise_im_params{ //struct to pass intermediate values within gnoise\nmat2 filter, sigma_f_plus_g_inv;\nfloat ainv, a_prime_square;\n};\n\nivec2 bound_grid(const ivec2 gpos){\nreturn gpos + IMOD*(1 - gpos/IMOD);\n}\n\n//hash based on Blum, Blum & Shub 1986\n//and Sharpe http://briansharpe.wordpress.com/2011/10/01/gpu-texture-free-noise/\nconst float bbsm = 137023.;//magic product of two primes chosen to have high period without float precision issues\nvec2 bbsmod( const vec2 a ) {\nreturn a - floor( a * ( 1.0 / bbsm ) ) * bbsm;\n}\nvec2 bbs(const vec2 a) {\nreturn bbsmod(a*a);\n}\nfloat bbsopt( const float a ) {\nreturn fract( a * a * ( 1.0 / bbsm ) ) * bbsm;\n}\nfloat seed(const ivec2 p){\nvec2 h = bbs(vec2(p.xy));\nreturn bbsopt(h.x+bbsopt(h.y))*(1./bbsm);\n}\n\n//permutation polynomial\n//based on Gustavson/McEwan https://github.com/ashima/webgl-noise/\n//and Sharpe http://briansharpe.wordpress.com/2011/10/01/gpu-texture-free-noise/\nconst float pp_epsilon = .01;\nfloat nextRand(inout float u){//rng\nu = fract(((u*34.0*289.)+1.0)*u+pp_epsilon);\nreturn fract(7.*u);\n}\n\n//approximate poisson distribution uniform u\n//from Galerne, Lagae, Lefebvre, Drettakis\nconst float poisson_epsilon = .001;\nint poisson(inout float u, const float m){\nfloat u1 = nextRand(u);\nfloat u2 = nextRand(u);\nfloat x = sqrt(-2.*log(u1+poisson_epsilon))*cos(2.*PI*u2);\nreturn int(m+sqrt(m)*x+.5);\n}\n\n//Gabor noise based on Lagae, Lefebvre, Drettakis, Dutre 2011\nfloat eval_cell(const vec2 cpos, const ivec2 gpos, const ivec2 dnbr, const gnoise_params params, const gnoise_im_params im_params){\nfloat u = seed(bound_grid(gpos+dnbr)); //deterministic seed for nbr cell\nint impulses = poisson(u, params.density*(1./PI)); //number of impulses in nbr cell\nvec4 h = params.sector; //annular sector\nfloat a = params.a; //bandwidth\nfloat aps = im_params.a_prime_square; //intermediate calculations for filtering\nfloat filt_scale = aps*im_params.ainv*im_params.ainv;\nvec2 fpos = cpos - vec2(dnbr);//fragment position in cell space\n\nfloat acc = 0.;\n//for impulses\nfor(int k=0; k<IMPULSE_CAP; k++){\nif(k<impulses){\n//position of impulse in cell space - uniform distribution\nvec2 ipos = vec2(nextRand(u), nextRand(u));\n//displacement to fragment\nvec2 delta = (fpos - ipos)*im_params.ainv;\n//impulse frequency, orientation - uniform distribution on input ranges\nfloat mfreq = pow(2., nextRand(u)*params.sector.y);\nfloat ifreq = h.x*mfreq;\nfloat iorientation = mix(h.z-.5*h.w, h.z+.5*h.w, nextRand(u));\n//evaluate kernel, accumulate fragment value\nvec2 mu = ifreq*vec2(cos(iorientation), sin(iorientation));\nfloat phi = nextRand(u); //phase - uniform dist [0, 1]\nfloat filt_exp = -.5*dot(mu, im_params.sigma_f_plus_g_inv*mu);\nacc+= filt_scale/mfreq*exp(-PI*aps*dot(delta,delta)+filt_exp)*cos(2.*PI*(dot(delta, im_params.filter*mu)+phi));\n}else {break;}\n}\nreturn acc;\n}\n\nfloat det2x2(const mat2 m){\nreturn (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\nmat2 inv2x2(const mat2 m){\nreturn (1./det2x2(m))*mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]);\n}\nmat2 id2x2(){\nreturn mat2(1.,0.,0.,1.);\n}\n\n//annular sector of pink noise\nfloat gnoise(vec2 pos, const gnoise_params params) {\ngnoise_im_params im_params;\nim_params.ainv = 1./params.a;\n\n//compute positions for this fragment\nvec2 temp = pos*params.a;\nvec2 cpos = fract(temp);\nivec2 gpos = bound_grid(ivec2(floor(temp)));\n\nmat2 jacob = params.jacob;\nmat2 jacob_t = mat2(jacob[0][0], jacob[1][0], jacob[0][1], jacob[1][1]);\nmat2 sigma_f_inv = (4.*PI*PI*params.filterSigma*params.filterSigma)*(jacob*jacob_t);\nmat2 sigma_f = inv2x2(sigma_f_inv);\nmat2 sigma_g_inv = (2.*PI*im_params.ainv*im_params.ainv)* id2x2();\nmat2 sigma_g = inv2x2(sigma_g_inv);\nmat2 sigma_fg_inv = sigma_f_inv + sigma_g_inv;\nmat2 sigma_fg = inv2x2(sigma_fg_inv);\n\n//filter params\nim_params.filter = sigma_fg * sigma_g_inv;\nim_params.sigma_f_plus_g_inv = inv2x2(sigma_f + sigma_g);\nim_params.a_prime_square = 2.*PI*sqrt(det2x2(sigma_fg));\n\nfloat value =\neval_cell(cpos, gpos, ivec2(-1, -1), params, im_params) +\neval_cell(cpos, gpos, ivec2(-1,  0), params, im_params) +\neval_cell(cpos, gpos, ivec2(-1,  1), params, im_params) +\neval_cell(cpos, gpos, ivec2( 0, -1), params, im_params) +\neval_cell(cpos, gpos, ivec2( 0,  0), params, im_params) +\neval_cell(cpos, gpos, ivec2( 0,  1), params, im_params) +\neval_cell(cpos, gpos, ivec2( 1, -1), params, im_params) +\neval_cell(cpos, gpos, ivec2( 1,  0), params, im_params) +\neval_cell(cpos, gpos, ivec2( 1,  1), params, im_params);\n\n\n//ad hoc attempt to normalize\nvalue*=.5*pow(params.density+1., -.5);\nfloat octexp = pow(2., params.sector.y);\nvalue*= (1.+params.sector.y)*octexp/(2.*octexp-1.);\n\nreturn value;\n}\n\n";
