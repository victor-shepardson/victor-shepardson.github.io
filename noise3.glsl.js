var genshader_noise3 = "#extension GL_OES_standard_derivatives : enable\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.1415926535897932384626\n#define IMPULSE_CAP 100\n#define IMOD 4096\n\nvarying vec2 vTextureCoordinates;\nvarying vec3 position;\n\nuniform float gridSize; //side length of square grid used for evaluation\nuniform float density; //number of impulses / kernel area (accuracy)\nuniform vec2 origin; //offset of image space from texture space\nuniform vec4 sector; //annular sector in frequency domain: fundamental freq, octaves, min orientation, max orientation\n\nuniform vec4 wsector;\nuniform float warp;\n\nstruct gnoise_params{\nmat2 filter, sigma_f_plus_g_inv;\nfloat ainv, a, a_prime_square, density, filterSigma, octaves;\nvec4 sector;\nmat2 jacob;\n};\n\nivec2 bound_grid(ivec2 gpos){\nreturn gpos + IMOD*(1 - gpos/IMOD);\n}\n\n//hash based on Blum, Blum & Shub 1986\n//and Sharpe http://briansharpe.wordpress.com/2011/10/01/gpu-texture-free-noise/\nconst float bbsm = 137023.;//magic product of two primes chosen to have high period without float precision issues\nvec4 bbsmod( vec4 a ) {\nreturn a - floor( a * ( 1.0 / bbsm ) ) * bbsm;\n}\nvec4 bbs(vec4 a) {\nreturn bbsmod(a*a);\n}\nvec4 bbsopt( vec4 a ) {\nreturn fract( a * a * ( 1.0 / bbsm ) ) * bbsm;\n}\nfloat seed(in ivec2 p){\nvec4 h = vec4(p.xy, p.xy+ivec2(1));\nvec4 h0 = bbs(h);\nvec4 h1 = bbsopt(h0.xzxz);\nvec4 h2 = bbsopt(h0.yyww+h1);\n//vec4 h3 = bbsopt(h0.xzxz+h2);\nreturn h2.x*(1./bbsm);\n}\n\n//permutation polynomial\n//based on Gustavson/McEwan https://github.com/ashima/webgl-noise/\n//and Sharpe http://briansharpe.wordpress.com/2011/10/01/gpu-texture-free-noise/\nconst float pp_epsilon = .01;\nfloat nextRand(inout float u){//rng\nu = fract(((u*34.0*289.)+1.0)*u+pp_epsilon);\nreturn fract(7.*u);\n}\n\n//approximate poisson distribution uniform u\n//from Galerne, Lagae, Lefebvre, Drettakis\nconst float poisson_epsilon = .001;\nint poisson(inout float u, in float m){\nfloat u1 = nextRand(u);\nfloat u2 = nextRand(u);\nfloat x = sqrt(-2.*log(u1+poisson_epsilon))*cos(2.*PI*u2);\nreturn int(m+sqrt(m)*x+.5);\n}\n\n//Gabor noise based on Lagae, Lefebvre, Drettakis, Dutre 2011\nfloat eval_cell(in vec2 cpos, in ivec2 gpos, in ivec2 dnbr, gnoise_params params){\nfloat u = seed(bound_grid(gpos+dnbr)); //deterministic seed for nbr cell\nint impulses = poisson(u, params.density); //number of impulses in nbr cell\nvec4 h = params.sector; //annular sector\nfloat a = params.a; //bandwidth\nfloat aps = params.a_prime_square; //intermediate calculations for filtering\nfloat filt_scale = aps*params.ainv*params.ainv;\nvec2 fpos = cpos - vec2(dnbr);//fragment position in cell space\n\nfloat acc = 0.;\n//for impulses\nfor(int k=0; k<IMPULSE_CAP; k++){\nif(k<impulses){\n//position of impulse in cell space - uniform distribution\nvec2 ipos = vec2(nextRand(u), nextRand(u));\n//displacement to fragment\nvec2 delta = (fpos - ipos)*gridSize;\n//impulse frequency, orientation - uniform distribution on input ranges\nfloat mfreq = pow(2., nextRand(u)*params.octaves);\nfloat ifreq = h.x*mfreq;\nfloat iorientation = mix(h.z, h.w, nextRand(u));\n//evaluate kernel, accumulate fragment value\nvec2 mu = ifreq*vec2(cos(iorientation), sin(iorientation));\nfloat phi = nextRand(u); //phase - uniform dist [0, 1]\nfloat filt_exp = -.5*dot(mu, params.sigma_f_plus_g_inv*mu);\nacc+= filt_scale/mfreq*exp(-PI*aps*dot(delta,delta)+filt_exp)*cos(2.*PI*(dot(delta, params.filter*mu)+phi));\n}else {break;}\n}\nreturn acc;\n}\n\nfloat det2x2(mat2 m){\nreturn (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\nmat2 inv2x2(mat2 m){\nreturn (1./det2x2(m))*mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]);\n}\nmat2 id2x2(){\nreturn mat2(1.,0.,0.,1.);\n}\n\n//annular sector of pink noise\nfloat gnoise(vec2 pos, gnoise_params params) {\n//compute positions for this fragment\nvec2 temp = pos*params.a;\nvec2 cpos = fract(temp);\nivec2 gpos = bound_grid(ivec2(floor(temp)));\n\nmat2 jacob = params.jacob;\nmat2 jacob_t = mat2(jacob[0][0], jacob[1][0], jacob[0][1], jacob[1][1]);\nmat2 sigma_f_inv = (4.*PI*PI*params.filterSigma*params.filterSigma)*(jacob*jacob_t);\nmat2 sigma_f = inv2x2(sigma_f_inv);\nmat2 sigma_g_inv = (2.*PI*params.ainv*params.ainv)* id2x2();\nmat2 sigma_g = inv2x2(sigma_g_inv);\nmat2 sigma_fg_inv = sigma_f_inv + sigma_g_inv;\nmat2 sigma_fg = inv2x2(sigma_fg_inv);\n\n//filter params\nparams.filter = sigma_fg * sigma_g_inv;\nparams.sigma_f_plus_g_inv = inv2x2(sigma_f + sigma_g);\nparams.a_prime_square = 2.*PI*sqrt(det2x2(sigma_fg));\n\nparams.octaves = params.sector.y;//log2(params.sector.y/params.sector.x);\n\nfloat value =\neval_cell(cpos, gpos, ivec2(-1, -1), params) +\neval_cell(cpos, gpos, ivec2(-1,  0), params) +\neval_cell(cpos, gpos, ivec2(-1,  1), params) +\neval_cell(cpos, gpos, ivec2( 0, -1), params) +\neval_cell(cpos, gpos, ivec2( 0,  0), params) +\neval_cell(cpos, gpos, ivec2( 0,  1), params) +\neval_cell(cpos, gpos, ivec2( 1, -1), params) +\neval_cell(cpos, gpos, ivec2( 1,  0), params) +\neval_cell(cpos, gpos, ivec2( 1,  1), params);\n\n//float lambda = params.a*params.a*params.density;\n\n//ad hoc attempt to normalize\n//value/=log2(2.+2.*params.density);\nvalue*=(1./PI)*pow(params.density, -.5);\n//value*=(1./3.)/log2(params.density+2.);\nfloat octexp = pow(2., params.octaves);\nvalue*= (1.+params.octaves)*octexp/(2.*octexp-1.);\n\nreturn value;\n}\n\nvoid main(void){\nvec2 pos = vTextureCoordinates.xy+origin.xy;\ngnoise_params params;\nparams.ainv = gridSize;\nparams.a = 1./params.ainv;\nparams.filterSigma = 1.;\nparams.jacob = mat2(dFdx(vTextureCoordinates.xy),dFdy(vTextureCoordinates.xy));\nparams.sector = sector;\nparams.density = density*(1./PI); //mean impulses per grid cell\n\ngnoise_params wparams;\nwparams.ainv = params.ainv;\nwparams.a = params.a;\nwparams.filterSigma = params.filterSigma;\nwparams.jacob = params.jacob;\nwparams.sector = wsector;\nwparams.density = params.density;\n\nvec2 p0 = vec2(1.,1.);\nfloat osx = gnoise(pos+p0, wparams);\n//float osy = gnoise(pos-p0, params);\npos=pos+warp*vec2(cos(PI*osx), sin(PI*osx));\n\nfloat value = gnoise(pos, params);\nvalue= value*.5+.5;\n\n//monochrome\nvec3 c = vec3(value,value,value);//.5*vec3(a_prime_square/(a*a));\n//draw fragment\ngl_FragColor = vec4(c, 1.0);\n}\n";
